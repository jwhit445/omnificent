using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using FraggerZGenerator.DynamoModels;

namespace FraggerZGenerator {

	public static class DynamoGenerator {

        private const string AUTOGENERATED_TEXT = "// This file is auto-generated.";
        private const string MODELS_FOLDER = @"..\..\..\..\..\api\src\models";
        private const string DATA_INTERFACE_FOLDER = @"..\..\..\..\..\api\src\datainterface";
        private const string DATA_INTERFACE_MODELS_FOLDER = @"..\..\..\..\..\api\src\datainterface\models";
        private const string INVERSE_INDEX_NAME = "InverseIndex";

        private static HashSet<string> _setGeneratedTypeNames = new HashSet<string>();

		public static void Generate() {
			List<Type> listFacetTypes = Assembly
				.GetExecutingAssembly()
				.GetTypes()
				.Where(x => x.GetCustomAttribute<DynamoKeyAttribute>() != null)
				.ToList();
            Directory.CreateDirectory(MODELS_FOLDER);
            Directory.CreateDirectory(DATA_INTERFACE_FOLDER);
            Directory.CreateDirectory(DATA_INTERFACE_MODELS_FOLDER);
            foreach(Type facetType in listFacetTypes) {
                GenerateTypescriptType(facetType);
                GenerateDataInterfaceClass(facetType);
			}
            Console.WriteLine("Dynamo Types Generated.");
		}

        private static void GenerateTypescriptType(Type type) {
            if(_setGeneratedTypeNames.Contains(type.Name)) {
                return;
			}
            _setGeneratedTypeNames.Add(type.Name);
            List<FieldInfo> listFields = type
                .GetFields()
                .OrderByDescending(x => x.Name.ToLower() == "pk")
                .ThenByDescending(x => x.Name.ToLower() == "sk")
                .Where(x => x.Name != "value__")
                .ToList();
            HashSet<Type> setImportedTypes = new HashSet<Type>();
            StringBuilder classBuilder = new StringBuilder();
            classBuilder.AppendLine($"export {(type.IsEnum ? "enum" : "class")} {type.Name} {{");
            foreach(FieldInfo field in listFields) {
                if(type.IsEnum) {
                    classBuilder.AppendLine($"\t{field.Name},");
                }
                else {
                    classBuilder.AppendLine($"\t{field.Name}?: {GetTypeScriptTypeFromField(field.FieldType, setImportedTypes)};");
                }
            }
            classBuilder.AppendLine("}");
            if(setImportedTypes.Count > 0) {
                classBuilder.Insert(0, "\r\n");
                foreach(Type importedType in setImportedTypes) {
                    GenerateTypescriptType(importedType);
                    classBuilder.Insert(0, $"import {{ {importedType.Name} }} from \"./{importedType.Name}\";\r\n");
				}
			}
            classBuilder.Insert(0, $"{AUTOGENERATED_TEXT}\r\n\r\n");
            File.WriteAllText($"{MODELS_FOLDER}\\{type.Name}.ts", classBuilder.ToString());
        }

        private static void GenerateDataInterfaceClass(Type facetType) {
            //Will generated the normal PK/SK setup, the inverse, and any other GSI functions.
            DynamoKeyAttribute keyAttr = facetType.GetCustomAttribute<DynamoKeyAttribute>();
            KeyFormat pkFormat = KeyFormat.ParseFormat(keyAttr.PK, facetType, DynamoKeyType.PK, "PK");
            bool pkSKEqual = keyAttr.PK == keyAttr.SK;
            KeyFormat skFormat = KeyFormat.ParseFormat(keyAttr.SK, facetType, DynamoKeyType.SK, "SK");
            var gsiGroups = facetType
                .GetFields()
                .Where(x => x.GetCustomAttribute<DynamoGSIKeyAttribute>() != null)
                .Select(x => (x, x.GetCustomAttribute<DynamoGSIKeyAttribute>()))
                .GroupBy(x => x.Item2.IndexName);
            List<(KeyFormat, KeyFormat, string, string)> listPKSKCombinations = new List<(KeyFormat, KeyFormat, string, string)>();
            listPKSKCombinations.Add((pkFormat, skFormat, "", ""));
            if(!pkSKEqual) {
                listPKSKCombinations.Add((skFormat, pkFormat, "Inverse", INVERSE_INDEX_NAME));
            }
            foreach(var group in gsiGroups) {
                if(group.Count() > 2) {
                    throw new ApplicationException($"Index: {group.Key} has too many properties with attributes.");
                }
                //GSI always require an SK field.
                (FieldInfo skField, DynamoGSIKeyAttribute skAttr) = group.FirstOrDefault(x => x.Item2.KeyType == DynamoKeyType.SK);
                if(skField == null) {
                    throw new ApplicationException($"Index: {group.Key} missing SK attribute for class: {facetType.Name}");
                }
                KeyFormat gsiSkFormat = KeyFormat.ParseFormat(skAttr.Format, facetType, DynamoKeyType.SK, skField.Name, facetType.Name + group.Key + "SK");
                //Optional. Will use regulard pk if anything.
                (FieldInfo pkField, DynamoGSIKeyAttribute pkAttr) = group.FirstOrDefault(x => x.Item2.KeyType == DynamoKeyType.PK);
                KeyFormat gsiPkFormat = pkField != null ? KeyFormat.ParseFormat(pkAttr.Format, facetType, DynamoKeyType.PK, pkField.Name, facetType.Name + group.Key + "PK") : pkFormat;
                listPKSKCombinations.Add((gsiPkFormat, gsiSkFormat, skAttr.IndexName, skAttr.IndexName));
            }
            StringBuilder strBuilder = new StringBuilder();
            strBuilder.AppendLine($"{AUTOGENERATED_TEXT}\r\n");
            strBuilder.AppendLine($"import DynamoDB from 'aws-sdk/clients/dynamodb';");
            HashSet<string> setImportedClasses = new HashSet<string>();
            foreach(KeyFormat keyFormat in listPKSKCombinations.SelectMany(x => {  
                    List<KeyFormat> listFormats = new List<KeyFormat>();
                    listFormats.Add(x.Item1);
			        if(x.Item1.Format != x.Item2.Format) {
                        listFormats.Add(x.Item2);
			        }
                return listFormats;
                })) {
                if(!setImportedClasses.Contains(keyFormat.PropertyClassName)) {
                    GenerateKeyPropType(keyFormat);
                    strBuilder.AppendLine($"import {{ {keyFormat.PropertyClassName} }} from \"./models/{keyFormat.PropertyClassName}\";");
                    setImportedClasses.Add(keyFormat.PropertyClassName);
                }
            }
            strBuilder.AppendLine();
            foreach((KeyFormat pFormat, KeyFormat sFormat, string methodSuffix, string indexName) in listPKSKCombinations) {
                strBuilder.AppendLine(GetDataInterfaceMethods(pFormat, sFormat, methodSuffix, indexName));
            }
            File.WriteAllText($"{DATA_INTERFACE_FOLDER}\\{facetType.Name}DataInterface.ts", strBuilder.ToString());
        }

        private static string GetDataInterfaceMethods(KeyFormat pk, KeyFormat sk, string methodSuffix = "", string indexName = "") {
            bool pkSKEqual = pk.Format == sk.Format;
            StringBuilder functionStrBuilder = new StringBuilder();
            functionStrBuilder.Append($"export async function getDB{methodSuffix}(dynamoDb: DynamoDB.DocumentClient, pk: {pk.PropertyClassName}");
            if(!pkSKEqual) {
                functionStrBuilder.Append($", sk: {sk.PropertyClassName}");
			}
            functionStrBuilder.AppendLine("): Promise<any> {");
            //All PK properties must be set.
            foreach(string propertyName in pk.ListProperties) {
                functionStrBuilder.AppendLine($"\tif(pk.{propertyName} === null || pk.{propertyName} === undefined) {{");
                functionStrBuilder.AppendLine($"\t\tthrow new Error(\"PK property: {propertyName} is not set.\")");
                functionStrBuilder.AppendLine("\t}");
			}
            functionStrBuilder.AppendLine("\tlet isPartialSK = true;");
            string pkKeyReplacement = $"`{pk.Format}`";
            foreach(string property in pk.ListProperties) {
                pkKeyReplacement = pkKeyReplacement.Replace($"{{{property}}}", $"${{pk.{property}}}");
            }
            functionStrBuilder.AppendLine($"\tconst pkKey = {pkKeyReplacement};");
            functionStrBuilder.Append(GetSKKeyCode(pk, sk));
            functionStrBuilder.AppendLine("\tconst params: any = {");
            functionStrBuilder.AppendLine("\t\tTableName: process.env.DYNAMODB_TABLE,");
            if(!string.IsNullOrWhiteSpace(indexName)) {
                functionStrBuilder.AppendLine($"\t\tIndexName: '{indexName}',");
            }
            functionStrBuilder.AppendLine($"\t\tKeyConditionExpression: `{pk.PropertyName} = :pkKey AND ${{isPartialSK ? \"begins_with({sk.PropertyName}, :skKey)\" : \"{sk.PropertyName} = :skKey\"}}`,");
            functionStrBuilder.AppendLine("\t\tExpressionAttributeValues: {");
            functionStrBuilder.AppendLine($"\t\t\t':pkKey': pkKey,");
            functionStrBuilder.AppendLine($"\t\t\t':skKey': skKey,");
            functionStrBuilder.AppendLine("\t\t},");
            functionStrBuilder.AppendLine("\t\tExclusiveStartKey: undefined,");
            functionStrBuilder.AppendLine("\t};");
            functionStrBuilder.AppendLine("\tconst retVal: any[] = [];");
            functionStrBuilder.AppendLine("\tdo {");
            functionStrBuilder.AppendLine("\t\tconst result = await dynamoDb.query(params).promise();");
            functionStrBuilder.AppendLine("\t\tif(result.Items) {");
            functionStrBuilder.AppendLine("\t\t\tretVal.push(...result.Items);");
            functionStrBuilder.AppendLine("\t\t}");
            functionStrBuilder.AppendLine("\t\tparams.ExclusiveStartKey = result.LastEvaluatedKey;");
            functionStrBuilder.AppendLine("\t} while(params.ExclusiveStartKey !== undefined && params.ExclusiveStartKey !== null);");
            functionStrBuilder.AppendLine("\treturn retVal;");
            functionStrBuilder.AppendLine("}");
            return functionStrBuilder.ToString();
		}

        private static string GetSKKeyCode(KeyFormat pk, KeyFormat sk) {
            StringBuilder strBuilder = new StringBuilder();
            bool pkSKEqual = pk.Format == sk.Format;
            int indexStartReplacement = sk.Format.IndexOf("{");
            int indexEndReplacement = sk.Format.IndexOf("}");
            string skFormatBeforeFirst = sk.Format.Substring(0, indexStartReplacement);
            strBuilder.AppendLine($"\tlet skKey = '{skFormatBeforeFirst}';");
            string skParameterName = pkSKEqual ? "pk" : "sk";
            int indentationLevel = 1;
            for(int i = 0; i < sk.ListProperties.Count; i++) {
                string property = sk.ListProperties[i];
                strBuilder.AppendLine($"{new string('\t', indentationLevel)}if({skParameterName}.{property} !== null && {skParameterName}.{property} !== undefined) {{");
                indexStartReplacement = sk.Format.IndexOf('{', indexEndReplacement + 1);
                string nextPart = "";
                if(indexStartReplacement != -1) {
                    nextPart = sk.Format.Substring(indexEndReplacement + 1, indexStartReplacement - indexEndReplacement - 1);
                }
                indexEndReplacement = sk.Format.IndexOf('}', indexEndReplacement + 1);
                strBuilder.AppendLine($"{new string('\t', indentationLevel + 1)}skKey += `${{{skParameterName}.{property}}}{nextPart}`");
                if(i == sk.ListProperties.Count - 1) {
                    strBuilder.AppendLine($"{new string('\t', indentationLevel + 1)}isPartialSK = false;");
				}
                indentationLevel++;
            }
            while(indentationLevel > 1) {
                strBuilder.AppendLine($"{new string('\t', indentationLevel - 1)}}}");
                indentationLevel--;
			}
            return strBuilder.ToString();
        }

        private static void GenerateKeyPropType(KeyFormat keyFormat) {
            if(_setGeneratedTypeNames.Contains(keyFormat.PropertyClassName)) {
                return;
			}
            _setGeneratedTypeNames.Add(keyFormat.PropertyClassName);
            StringBuilder strBuilder = new StringBuilder();
            strBuilder.AppendLine($"export class {keyFormat.PropertyClassName} {{");
            HashSet<Type> setImportedTypes = new HashSet<Type>();
            foreach(string propertyName in keyFormat.ListProperties) {
                FieldInfo fieldInfo = keyFormat.FacetType.GetField(propertyName);
                strBuilder.AppendLine($"\t{fieldInfo.Name}?: {GetTypeScriptTypeFromField(fieldInfo.FieldType, setImportedTypes)};");
            }
            strBuilder.AppendLine("}");
            if(setImportedTypes.Count > 0) {
                strBuilder.Insert(0, "\r\n");
                foreach(Type importedType in setImportedTypes) {
                    GenerateTypescriptType(importedType);
                    strBuilder.Insert(0, $"import {{ {importedType.Name} }} from \"../../models/{importedType.Name}\";\r\n");
                }
            }
            strBuilder.Insert(0, $"{AUTOGENERATED_TEXT}\r\n\r\n");
            File.WriteAllText($"{DATA_INTERFACE_MODELS_FOLDER}\\{keyFormat.PropertyClassName}.ts", strBuilder.ToString());
        }

        private static string GetTypeScriptTypeFromField(Type type, HashSet<Type> setImportedTypes) {
            string typeStr;
            if(type == typeof(string)) {
                typeStr = "string";
			}
            else if(type == typeof(int) || type == typeof(float) || type == typeof(double) || type == typeof(decimal)) {
                typeStr = "number";
			}
            else if(type == typeof(DateTime)) {
                typeStr = "Date";
			}
            else if(type == typeof(bool)) {
                typeStr = "boolean";
            }
            else if(IsListType(type)) {
                typeStr = $"{GetTypeScriptTypeFromField(type.GetGenericArguments()[0], setImportedTypes)}[]";
            }
            else {
                setImportedTypes.Add(type);
                typeStr = type.Name;
			}
            return typeStr;
		}

        private static bool IsListType(Type type) {
            return type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>);

        }

        private class KeyFormat {

            public string Format;

            public List<string> ListProperties;

            public string PropertyClassName;

            public DynamoKeyType KeyType;

            public Type FacetType;

            public string PropertyName;

            public static KeyFormat ParseFormat(string format, Type objectType, DynamoKeyType keyType, string propertyName, string propertyClassNameOverride = "") {
                KeyFormat keyFormat = new KeyFormat();
                keyFormat.Format = format;
                keyFormat.KeyType = keyType;
                keyFormat.FacetType = objectType;
                keyFormat.PropertyName = propertyName;
                if(!string.IsNullOrWhiteSpace(propertyClassNameOverride)) {
                    keyFormat.PropertyClassName = propertyClassNameOverride;
				}
                else if(keyType == DynamoKeyType.PK) {
                    //Pks are shared accross multiple facets and should be based on the base class for the facet.
                    //i.e. LadderSettings pk should be called Ladder_PK.
                    string baseClassName = objectType.BaseType.Name;
                    if(!baseClassName.EndsWith("Base")) {
                        throw new ApplicationException($"Class: {objectType.Name} base class: {baseClassName} should end with Base.");
					}
                    baseClassName = baseClassName.Substring(0, baseClassName.Length - 4);
                    keyFormat.PropertyClassName = $"{baseClassName}PK";
				}
                else {
                    keyFormat.PropertyClassName = $"{objectType.Name}SK";
				}
                keyFormat.ListProperties = format
                    .Split("#")
                    .Select(x => x.Trim('#'))
                    .Where(x => x.StartsWith("{") && x.EndsWith("}"))
                    .Select(x => x.Trim('{').Trim('}'))
                    .ToList();
                foreach(string property in keyFormat.ListProperties) {
                    if(objectType.GetField(property) == null) {
                        throw new ApplicationException($"Type: {objectType.Name} is missing property: {property} in KeyType: {keyType}.");
                    }
                }
                return keyFormat;
			}
		}
	}

}
